<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speckle Size Calculator - Correlated Solutions</title>
    <!-- JSZip for reading .z3d calibration files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --csi-blue: #1a5276;
            --csi-light-blue: #2980b9;
            --csi-dark: #2c3e50;
            --csi-success: #27ae60;
            --csi-warning: #f39c12;
            --csi-light-gray: #ecf0f1;
            --csi-white: #ffffff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            background: var(--csi-blue);
            color: var(--csi-white);
            padding: 25px 30px;
            border-radius: 12px 12px 0 0;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .calculator {
            background: var(--csi-white);
            padding: 30px;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: var(--csi-dark);
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .form-group label .hint {
            font-weight: normal;
            color: #7f8c8d;
            font-size: 0.85em;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #dde4e6;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--csi-light-blue);
            box-shadow: 0 0 0 3px rgba(41, 128, 185, 0.1);
        }

        .fov-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .unit-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .unit-toggle button {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--csi-light-blue);
            background: var(--csi-white);
            color: var(--csi-light-blue);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .unit-toggle button.active {
            background: var(--csi-light-blue);
            color: var(--csi-white);
        }

        .unit-toggle button:hover:not(.active) {
            background: rgba(41, 128, 185, 0.1);
        }

        .calculate-btn {
            width: 100%;
            padding: 15px;
            background: var(--csi-blue);
            color: var(--csi-white);
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }

        .calculate-btn:hover {
            background: var(--csi-light-blue);
            transform: translateY(-2px);
        }

        .results {
            margin-top: 30px;
            display: none;
        }

        .results.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .results-header {
            background: var(--csi-light-gray);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .results-header h3 {
            color: var(--csi-dark);
            margin-bottom: 5px;
        }

        .pixel-info {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .recommendation-card {
            background: linear-gradient(135deg, var(--csi-blue) 0%, var(--csi-light-blue) 100%);
            color: var(--csi-white);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .recommendation-card h4 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .recommended-size {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .recommended-label {
            opacity: 0.9;
        }

        .speckle-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .range-card {
            background: var(--csi-light-gray);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .range-card .label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .range-card .value {
            font-size: 1.4em;
            font-weight: 700;
            color: var(--csi-dark);
        }

        .range-card .pixels {
            font-size: 0.85em;
            color: var(--csi-light-blue);
            margin-top: 3px;
        }

        .kit-sizes {
            background: var(--csi-light-gray);
            padding: 20px;
            border-radius: 8px;
        }

        .kit-sizes h4 {
            color: var(--csi-dark);
            margin-bottom: 15px;
            font-size: 0.95em;
        }

        .size-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }

        .size-chip {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            color: var(--csi-white);
            border: 3px solid transparent;
            transition: all 0.3s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 110px;
        }

        .size-chip small {
            display: block;
            margin-top: 4px;
            font-size: 0.8em;
            opacity: 0.9;
        }

        /* Kit color coding - matches physical roller/stamp band colors */
        .size-chip.size-007 {
            background: #222222; /* Black band */
            color: #fff;
        }
        .size-chip.size-013 {
            background: #FFD700; /* Yellow band */
            color: #333;
            text-shadow: none;
        }
        .size-chip.size-026 {
            background: #228B22; /* Green band */
            color: #fff;
        }
        .size-chip.size-05 {
            background: #DC143C; /* Red band */
            color: #fff;
        }
        .size-chip.size-10 {
            background: #f5f5f5; /* White band */
            color: #333;
            text-shadow: none;
            border-color: #ccc;
        }
        .size-chip.size-20 {
            background: #1E90FF; /* Blue band */
            color: #fff;
        }

        /* Recommended indicator - add glow effect */
        .size-chip.recommended {
            border-color: #000;
            box-shadow: 0 0 0 3px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }

        /* Dim chips that are outside acceptable range */
        .size-chip.out-of-range {
            opacity: 0.4;
            filter: grayscale(50%);
        }

        .size-chip.acceptable {
            opacity: 1;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px 20px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
            font-size: 0.8em;
            color: #7f8c8d;
        }

        .legend-title {
            width: 100%;
            font-weight: 600;
            color: var(--csi-dark);
            margin-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .legend-dot.black { background: #222222; }
        .legend-dot.yellow { background: #FFD700; }
        .legend-dot.green { background: #228B22; }
        .legend-dot.red { background: #DC143C; }
        .legend-dot.white { background: #f5f5f5; border: 1px solid #ccc; }
        .legend-dot.blue { background: #1E90FF; }

        .legend-dot.recommended-indicator {
            background: #fff;
            border: 3px solid #000;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.2);
        }

        .camera-specs {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.85em;
            color: #7f8c8d;
        }

        .camera-specs strong {
            color: var(--csi-dark);
        }

        /* Calibration file upload section */
        .divider {
            display: flex;
            align-items: center;
            margin: 25px 0;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #dde4e6;
        }

        .divider span {
            padding: 0 15px;
            font-weight: 600;
        }

        .file-upload-area {
            border: 2px dashed #dde4e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            background: #fafbfc;
        }

        .file-upload-area:hover {
            border-color: var(--csi-light-blue);
            background: rgba(41, 128, 185, 0.05);
        }

        .file-upload-area.dragover {
            border-color: var(--csi-light-blue);
            background: rgba(41, 128, 185, 0.1);
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .file-upload-icon {
            font-size: 2.5em;
            color: #bdc3c7;
            margin-bottom: 10px;
        }

        .file-upload-text {
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .file-upload-text strong {
            color: var(--csi-light-blue);
        }

        .file-upload-hint {
            font-size: 0.8em;
            color: #95a5a6;
        }

        .calibration-info {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            color: #2e7d32;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .calibration-info.show {
            display: block;
        }

        .calibration-info .cal-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .calibration-info .cal-details {
            font-size: 0.9em;
        }

        .calibration-info .cal-details span {
            display: inline-block;
            margin-right: 20px;
        }

        .warning-message {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .info-message {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            color: #0c5460;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        .out-of-range-alert {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .out-of-range-alert h4 {
            font-size: 1.1em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .out-of-range-alert p {
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .out-of-range-alert .alternatives {
            background: rgba(255,255,255,0.15);
            padding: 12px 15px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .out-of-range-alert .alternatives strong {
            display: block;
            margin-bottom: 8px;
        }

        .out-of-range-alert .alternatives ul {
            margin: 0;
            padding-left: 20px;
        }

        .out-of-range-alert .alternatives li {
            margin-bottom: 4px;
        }

        .recommendation-card.out-of-range {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .recommendation-card.out-of-range .recommended-size {
            text-decoration: line-through;
            opacity: 0.7;
            font-size: 2em;
        }

        .recommendation-card .ideal-size-note {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.3);
            font-size: 0.9em;
            opacity: 0.9;
        }

        @media (max-width: 600px) {
            .fov-inputs, .speckle-range {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.4em;
            }

            .recommended-size {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Speckle Size Calculator</h1>
            <p>Find the optimal speckle pattern for your DIC application</p>
        </div>

        <div class="calculator">
            <!-- Introduction Section -->
            <div class="intro-section" style="margin-bottom: 25px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid var(--csi-blue);">
                <h3 style="color: var(--csi-dark); margin-bottom: 10px; font-size: 1.1em;">How This Calculator Works</h3>
                <p style="color: #555; font-size: 0.95em; line-height: 1.6; margin-bottom: 10px;">
                    For accurate Digital Image Correlation (DIC) measurements, speckle patterns should be <strong>3-5 pixels in diameter</strong>
                    as recommended by the iDICs Good Practices Guide. This calculator determines your camera's pixel scale
                    (physical size per pixel) based on your resolution and field of view, then recommends the optimal
                    Correlated Solutions Speckle Kit size to achieve this target.
                </p>
                <p style="color: #7f8c8d; font-size: 0.85em; margin: 0;">
                    <strong>Tip:</strong> Select your camera from the dropdown below, or choose "Enter custom resolution..." at the bottom of the list for unlisted cameras.
                </p>
            </div>

            <!-- Calibration File Upload Section -->
            <div class="form-group">
                <label>Load from Calibration File <span class="hint">(optional - auto-fills pixel scale)</span></label>
                <div class="file-upload-area" id="dropZone" onclick="document.getElementById('calibrationFile').click()">
                    <input type="file" id="calibrationFile" accept=".z3d,.zip" onchange="handleCalibrationFile(this.files[0])">
                    <div class="file-upload-icon">üìÅ</div>
                    <div class="file-upload-text"><strong>Click to upload</strong> or drag & drop</div>
                    <div class="file-upload-hint">.z3d calibration file</div>
                </div>
                <div class="calibration-info" id="calibrationInfo">
                    <div class="cal-title">‚úì Calibration Loaded</div>
                    <div class="cal-details">
                        <span>Resolution: <strong id="calResolution">--</strong></span>
                        <span>Pixel Scale: <strong id="calPixelScale">--</strong></span>
                    </div>
                </div>
            </div>

            <div class="divider"><span>OR enter manually</span></div>

            <div class="form-group">
                <label for="camera">Select Camera</label>
                <select id="camera">
                    <option value="">-- Select your camera --</option>
                    <optgroup label="Basler Ace">
                        <option value="720,540,6.9">Ace 0.4MP (720√ó540) IMX287 - 6.9Œºm</option>
                        <option value="1920,1200,5.86">Ace 2.3MP (1920√ó1200) IMX174 - 5.86Œºm</option>
                        <option value="1920,1200,5.86">Ace 2.3MP (1920√ó1200) IMX249 - 5.86Œºm</option>
                        <option value="2048,1536,3.45">Ace 3.2MP (2048√ó1536) IMX252 - 3.45Œºm</option>
                        <option value="2448,2048,3.45">Ace 5.0MP (2448√ó2048) IMX250 - 3.45Œºm</option>
                        <option value="4096,2160,3.45">Ace 8.9MP (4096√ó2160) IMX255 - 3.45Œºm</option>
                        <option value="4096,3000,3.45">Ace 12.3MP (4096√ó3000) IMX253 - 3.45Œºm</option>
                    </optgroup>
                    <optgroup label="Basler Ace2">
                        <option value="2448,2048,2.74">Ace2 5MP (2448√ó2048) IMX547 - 2.74Œºm</option>
                        <option value="2840,2840,2.74">Ace2 8MP (2840√ó2840) IMX546 - 2.74Œºm</option>
                        <option value="4096,3000,2.74">Ace2 12.3MP (4096√ó3000) IMX545 - 2.74Œºm</option>
                        <option value="5320,3032,2.74">Ace2 16.1MP (5320√ó3032) IMX542 - 2.74Œºm</option>
                        <option value="4504,4504,2.74">Ace2 20.2MP (4504√ó4504) IMX541 - 2.74Œºm</option>
                        <option value="5328,4608,2.74">Ace2 24.5MP (5328√ó4608) IMX540 - 2.74Œºm</option>
                    </optgroup>
                    <optgroup label="Basler Boost">
                        <option value="1936,1464,4.5">Boost 2.8MP (1936√ó1464) IMX421 - 4.5Œºm</option>
                        <option value="2448,2048,2.74">Boost 5MP (2448√ó2048) IMX537 - 2.74Œºm</option>
                        <option value="2840,2840,2.74">Boost 8MP (2840√ó2840) IMX536 - 2.74Œºm</option>
                        <option value="4096,2168,3.45">Boost 9MP (4096√ó2168) IMX255 - 3.45Œºm</option>
                        <option value="4096,3000,3.45">Boost 12.3MP (4096√ó3000) IMX253 - 3.45Œºm</option>
                        <option value="4096,3000,2.74">Boost 12.3MP (4096√ó3000) IMX535 - 2.74Œºm</option>
                        <option value="5320,3032,2.74">Boost 16.1MP (5320√ó3032) IMX532 - 2.74Œºm</option>
                        <option value="4504,4504,2.74">Boost 20MP (4504√ó4504) IMX531 - 2.74Œºm</option>
                        <option value="4500,4500,3.2">Boost 20MP (4500√ó4500) XGS20000 - 3.2Œºm</option>
                        <option value="5328,4608,2.74">Boost 24.5MP (5328√ó4608) IMX530 - 2.74Œºm</option>
                        <option value="6580,4935,3.2">Boost 32MP (6580√ó4935) XGS32000 - 3.2Œºm</option>
                        <option value="8192,5460,3.2">Boost 45MP (8192√ó5460) XGS45000 - 3.2Œºm</option>
                    </optgroup>
                    <optgroup label="FLIR Oryx">
                        <option value="2448,2048,3.45">Oryx 5MP (2448√ó2048) IMX250 - 3.45Œºm</option>
                        <option value="4096,2160,3.45">Oryx 9MP (4096√ó2160) IMX255 - 3.45Œºm</option>
                        <option value="4096,3000,3.45">Oryx 12MP (4096√ó3000) IMX253 - 3.45Œºm</option>
                        <option value="6464,4852,3.45">Oryx 31MP (6464√ó4852) IMX342 - 3.45Œºm</option>
                    </optgroup>
                    <optgroup label="AVT Alvium">
                        <option value="1936,1216,3.45">Alvium 2.4MP (1936√ó1216) IMX392 - 3.45Œºm</option>
                        <option value="2064,1544,3.45">Alvium 3.2MP (2064√ó1544) IMX252 - 3.45Œºm</option>
                        <option value="2464,2056,3.45">Alvium 5.1MP (2464√ó2056) IMX264 - 3.45Œºm</option>
                        <option value="2848,2848,2.74">Alvium 8.1MP (2848√ó2848) IMX546 - 2.74Œºm</option>
                        <option value="4112,3008,3.45">Alvium 12.4MP (4112√ó3008) IMX304 - 3.45Œºm</option>
                    </optgroup>
                    <optgroup label="High Speed Cameras">
                        <option value="1024,1024,0">Full Resolution High Speed (1024√ó1024)</option>
                    </optgroup>
                    <optgroup label="Custom">
                        <option value="custom">Enter custom resolution...</option>
                    </optgroup>
                </select>
            </div>

            <div id="customResolution" class="form-group" style="display: none;">
                <label>Custom Camera Resolution</label>
                <div class="fov-inputs">
                    <div>
                        <input type="number" id="customWidth" placeholder="Width (pixels)" min="1">
                    </div>
                    <div>
                        <input type="number" id="customHeight" placeholder="Height (pixels)" min="1">
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>Field of View Units</label>
                <div class="unit-toggle">
                    <button type="button" id="unitInches" class="active">Inches</button>
                    <button type="button" id="unitMm">Millimeters</button>
                </div>
            </div>

            <div class="form-group">
                <label>Field of View Dimensions <span class="hint">(the physical size your camera will image)</span></label>
                <div class="fov-inputs">
                    <div>
                        <input type="number" id="fovWidth" placeholder="Width" step="0.1" min="0.1">
                    </div>
                    <div>
                        <input type="number" id="fovHeight" placeholder="Height" step="0.1" min="0.1">
                    </div>
                </div>
            </div>

            <button type="button" class="calculate-btn" onclick="calculate()">Calculate Recommended Speckle Size</button>

            <div id="results" class="results">
                <!-- Results will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        // Calibration data from .z3d file (if loaded)
        let calibrationData = null;

        // Speckle kit available sizes in inches
        const KIT_SIZES = [0.007, 0.013, 0.026, 0.05, 0.10, 0.20];
        const KIT_SIZES_MM = [0.18, 0.33, 0.66, 1.27, 2.54, 5.08];
        // CSS class names matching physical roller band colors
        const KIT_COLOR_CLASSES = ['size-007', 'size-013', 'size-026', 'size-05', 'size-10', 'size-20'];

        // Target pixels per speckle
        const MIN_PIXELS = 3;
        const MAX_PIXELS = 5;
        const IDEAL_PIXELS = 4;

        let useInches = true;

        // Drag and drop handlers
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                handleCalibrationFile(file);
            }
        });

        // Handle .z3d calibration file
        async function handleCalibrationFile(file) {
            if (!file) return;

            try {
                const zip = await JSZip.loadAsync(file);

                // Find XML file in the zip
                let xmlContent = null;
                let xmlFileName = null;

                for (const fileName of Object.keys(zip.files)) {
                    if (fileName.endsWith('.xml')) {
                        xmlContent = await zip.files[fileName].async('text');
                        xmlFileName = fileName;
                        break;
                    }
                }

                if (!xmlContent) {
                    alert('No XML file found in the .z3d archive');
                    return;
                }

                // Parse XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');

                // Try to extract calibration data
                // NOTE: Update these selectors based on actual XML structure
                const extractedData = extractCalibrationData(xmlDoc);

                if (extractedData) {
                    calibrationData = extractedData;
                    displayCalibrationInfo(extractedData);
                } else {
                    alert('Could not find pixel scale data in the calibration file. Please enter values manually.');
                }

            } catch (error) {
                console.error('Error reading calibration file:', error);
                alert('Error reading calibration file: ' + error.message);
            }
        }

        // Extract calibration data from VIC-3D .z3d XML structure
        function extractCalibrationData(xmlDoc) {
            let pixelScaleMmPerPx = null;
            let width = null;
            let height = null;
            let cameraId = 0; // Default to camera 0

            // 1. Look for magnification elements (contains pixels/mm values)
            // Format: <magnification id="0">10.808 10.3905 11.3201</magnification>
            // Values are: mean, min, max in pixels/mm
            const magnificationElements = xmlDoc.getElementsByTagName('magnification');
            for (let elem of magnificationElements) {
                const id = elem.getAttribute('id');
                if (id === '0' || id === null) { // Use camera 0 or first found
                    const values = elem.textContent.trim().split(/\s+/);
                    if (values.length >= 1) {
                        const pixelsPerMm = parseFloat(values[0]); // Use mean value
                        if (!isNaN(pixelsPerMm) && pixelsPerMm > 0) {
                            pixelScaleMmPerPx = 1.0 / pixelsPerMm; // Convert to mm/pixel
                            cameraId = id || '0';
                            break;
                        }
                    }
                }
            }

            // 2. Look for image dimensions in polygonmask element
            // Format: <polygonmask height="2056" width="2464">
            const polygonmaskElements = xmlDoc.getElementsByTagName('polygonmask');
            for (let elem of polygonmaskElements) {
                const w = elem.getAttribute('width');
                const h = elem.getAttribute('height');
                if (w && h) {
                    width = parseInt(w);
                    height = parseInt(h);
                    break;
                }
            }

            // 3. Fallback: Try to find dimensions in other elements
            if (!width || !height) {
                const allElements = xmlDoc.getElementsByTagName('*');
                for (let elem of allElements) {
                    const w = elem.getAttribute('width');
                    const h = elem.getAttribute('height');
                    if (w && h) {
                        const wVal = parseInt(w);
                        const hVal = parseInt(h);
                        // Reasonable image dimensions
                        if (wVal > 500 && wVal < 20000 && hVal > 500 && hVal < 20000) {
                            width = wVal;
                            height = hVal;
                            break;
                        }
                    }
                }
            }

            if (pixelScaleMmPerPx) {
                return {
                    pixelScale: pixelScaleMmPerPx, // mm/pixel
                    width: width,
                    height: height,
                    unit: 'mm',
                    cameraId: cameraId
                };
            }

            return null;
        }

        // Display loaded calibration info
        function displayCalibrationInfo(data) {
            const infoDiv = document.getElementById('calibrationInfo');
            document.getElementById('calResolution').textContent =
                data.width && data.height ? `${data.width} x ${data.height} px` : 'N/A';

            // Show pixel scale in both mm/pixel and pixels/mm
            const pixelsPerMm = 1.0 / data.pixelScale;
            document.getElementById('calPixelScale').textContent =
                `${data.pixelScale.toFixed(4)} mm/pixel (${pixelsPerMm.toFixed(2)} px/mm)`;

            infoDiv.classList.add('show');

            // Auto-fill the form if we have resolution data
            if (data.width && data.height) {
                document.getElementById('camera').value = 'custom';
                document.getElementById('customResolution').style.display = 'block';
                document.getElementById('customWidth').value = data.width;
                document.getElementById('customHeight').value = data.height;

                // Calculate and show effective FOV
                const fovWidthMm = data.pixelScale * data.width;
                const fovHeightMm = data.pixelScale * data.height;
                document.getElementById('fovWidth').value = fovWidthMm.toFixed(1);
                document.getElementById('fovHeight').value = fovHeightMm.toFixed(1);

                // Set units to mm since calibration is in mm
                useInches = false;
                document.getElementById('unitMm').classList.add('active');
                document.getElementById('unitInches').classList.remove('active');
            }
        }

        // Unit toggle handlers
        document.getElementById('unitInches').addEventListener('click', function() {
            useInches = true;
            this.classList.add('active');
            document.getElementById('unitMm').classList.remove('active');
        });

        document.getElementById('unitMm').addEventListener('click', function() {
            useInches = false;
            this.classList.add('active');
            document.getElementById('unitInches').classList.remove('active');
        });

        // Camera selection handler
        document.getElementById('camera').addEventListener('change', function() {
            const customDiv = document.getElementById('customResolution');
            if (this.value === 'custom') {
                customDiv.style.display = 'block';
            } else {
                customDiv.style.display = 'none';
            }
        });

        function calculate() {
            let width, height, pixelScale;
            let fovWidth, fovHeight;
            let fromCalibration = false;

            // Check if we have calibration data with pixel scale
            if (calibrationData && calibrationData.pixelScale) {
                // Use calibration pixel scale directly
                pixelScale = calibrationData.pixelScale / 25.4; // Convert mm to inches
                width = calibrationData.width || 0;
                height = calibrationData.height || 0;
                fromCalibration = true;

                // Calculate effective FOV from pixel scale
                fovWidth = pixelScale * width;
                fovHeight = pixelScale * height;
            } else {
                // Manual entry mode
                const cameraSelect = document.getElementById('camera');

                if (cameraSelect.value === 'custom') {
                    width = parseInt(document.getElementById('customWidth').value);
                    height = parseInt(document.getElementById('customHeight').value);
                } else if (cameraSelect.value) {
                    const parts = cameraSelect.value.split(',');
                    width = parseInt(parts[0]);
                    height = parseInt(parts[1]);
                } else {
                    alert('Please select a camera or load a calibration file');
                    return;
                }

                fovWidth = parseFloat(document.getElementById('fovWidth').value);
                fovHeight = parseFloat(document.getElementById('fovHeight').value);

                if (!width || !height || !fovWidth || !fovHeight) {
                    alert('Please fill in all fields');
                    return;
                }

                // Convert mm to inches if needed
                if (!useInches) {
                    fovWidth = fovWidth / 25.4;
                    fovHeight = fovHeight / 25.4;
                }

                // Calculate pixel scale (inches per pixel) using the larger dimension
                const pixelScaleW = fovWidth / width;
                const pixelScaleH = fovHeight / height;
                pixelScale = Math.max(pixelScaleW, pixelScaleH);
            }

            // Calculate ideal speckle size range (in inches)
            const minSpeckleSize = pixelScale * MIN_PIXELS;
            const maxSpeckleSize = pixelScale * MAX_PIXELS;
            const idealSpeckleSize = pixelScale * IDEAL_PIXELS;

            // Find the best kit size
            let bestSize = findBestKitSize(idealSpeckleSize, minSpeckleSize, maxSpeckleSize);

            // Categorize all kit sizes
            const categorizedSizes = KIT_SIZES.map((size, index) => {
                const pixelsPerSpeckle = size / pixelScale;
                const isRecommended = size === bestSize;
                const isAcceptable = pixelsPerSpeckle >= MIN_PIXELS && pixelsPerSpeckle <= 10;

                return {
                    sizeInches: size,
                    sizeMm: KIT_SIZES_MM[index],
                    pixels: pixelsPerSpeckle,
                    colorClass: KIT_COLOR_CLASSES[index],
                    isRecommended: isRecommended,
                    isAcceptable: isAcceptable
                };
            });

            // Display results
            displayResults({
                cameraWidth: width,
                cameraHeight: height,
                fovWidth: useInches ? fovWidth : fovWidth * 25.4,
                fovHeight: useInches ? fovHeight : fovHeight * 25.4,
                pixelScale: pixelScale,
                minSpeckle: minSpeckleSize,
                maxSpeckle: maxSpeckleSize,
                idealSpeckle: idealSpeckleSize,
                bestKitSize: bestSize,
                bestKitSizeMm: KIT_SIZES_MM[KIT_SIZES.indexOf(bestSize)],
                categorizedSizes: categorizedSizes,
                useInches: useInches
            });
        }

        function findBestKitSize(ideal, min, max) {
            // Find the kit size closest to ideal that falls within acceptable range
            let best = KIT_SIZES[0];
            let bestDiff = Infinity;

            for (const size of KIT_SIZES) {
                const diff = Math.abs(size - ideal);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    best = size;
                }
            }
            return best;
        }

        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const pixelsWithBest = data.bestKitSize / data.pixelScale;

            // Check if ideal size is outside kit range
            const smallestKit = KIT_SIZES[0]; // 0.007"
            const largestKit = KIT_SIZES[KIT_SIZES.length - 1]; // 0.20"
            const isTooSmallForKit = data.idealSpeckle < smallestKit;
            const isTooLargeForKit = data.idealSpeckle > largestKit;
            const isOutOfRange = isTooSmallForKit || isTooLargeForKit;

            let warningHtml = '';
            let outOfRangeAlert = '';

            if (isTooSmallForKit) {
                const idealInMm = data.idealSpeckle * 25.4;
                outOfRangeAlert = `
                    <div class="out-of-range-alert">
                        <h4>‚ö†Ô∏è Ideal Speckle Size is Smaller Than Kit Range</h4>
                        <p>
                            Your setup requires speckles around <strong>${data.idealSpeckle.toFixed(4)}" (${idealInMm.toFixed(3)} mm)</strong>
                            for optimal 3-5 pixel coverage, but our smallest kit size is <strong>0.007" (0.18 mm)</strong>.
                        </p>
                        <div class="alternatives">
                            <strong>Alternative Patterning Methods:</strong>
                            <ul>
                                <li><strong>Airbrush:</strong> Fine mist spray paint can achieve very small, random speckle patterns</li>
                                <li><strong>Spray Paint:</strong> Light dusting from distance creates fine speckles</li>
                                <li><strong>Toner Transfer:</strong> Laser printer toner patterns for microscale applications</li>
                                <li><strong>Commercial Patterns:</strong> Pre-printed speckle pattern decals or films</li>
                            </ul>
                        </div>
                        <p style="margin-top: 12px; margin-bottom: 0; opacity: 0.9;">
                            <strong>Tip:</strong> Consider increasing your field of view or using a lower resolution camera
                            to bring the required speckle size into kit range.
                        </p>
                    </div>
                `;
            } else if (isTooLargeForKit) {
                const idealInMm = data.idealSpeckle * 25.4;
                outOfRangeAlert = `
                    <div class="out-of-range-alert">
                        <h4>‚ö†Ô∏è Ideal Speckle Size is Larger Than Kit Range</h4>
                        <p>
                            Your setup requires speckles around <strong>${data.idealSpeckle.toFixed(3)}" (${idealInMm.toFixed(2)} mm)</strong>
                            for optimal 3-5 pixel coverage, but our largest kit size is <strong>0.20" (5.08 mm)</strong>.
                        </p>
                        <div class="alternatives">
                            <strong>Alternative Patterning Methods:</strong>
                            <ul>
                                <li><strong>Hand Painting:</strong> Use a brush or dauber to create larger random dots</li>
                                <li><strong>Stencils:</strong> Custom stencils with appropriately sized holes</li>
                                <li><strong>Adhesive Dots:</strong> Pre-cut vinyl or paper dots</li>
                                <li><strong>Printed Patterns:</strong> Large-format printed speckle patterns</li>
                            </ul>
                        </div>
                        <p style="margin-top: 12px; margin-bottom: 0; opacity: 0.9;">
                            <strong>Tip:</strong> Consider decreasing your field of view or using a higher resolution camera
                            to bring the required speckle size into kit range.
                        </p>
                    </div>
                `;
            } else if (pixelsWithBest < 3) {
                warningHtml = `
                    <div class="warning-message">
                        <strong>Warning:</strong> The recommended kit size will produce speckles smaller than 3 pixels.
                        Consider using a smaller field of view or a higher resolution camera for optimal results.
                    </div>
                `;
            } else if (pixelsWithBest > 10) {
                warningHtml = `
                    <div class="info-message">
                        <strong>Note:</strong> Speckles will be larger than the optimal 5-10 pixel range, but this is
                        acceptable as long as they are consistent in size. You may need to increase subset size.
                    </div>
                `;
            }

            const unitLabel = data.useInches ? 'in' : 'mm';
            const displayMin = data.useInches ? data.minSpeckle : data.minSpeckle * 25.4;
            const displayMax = data.useInches ? data.maxSpeckle : data.maxSpeckle * 25.4;
            const displayBest = data.useInches ? data.bestKitSize : data.bestKitSizeMm;
            const displayIdeal = data.useInches ? data.idealSpeckle : data.idealSpeckle * 25.4;

            // Build recommendation card based on whether in range or not
            let recommendationCard = '';
            if (isOutOfRange) {
                recommendationCard = `
                    <div class="recommendation-card out-of-range">
                        <h4>Closest Speckle Kit Size (Not Ideal)</h4>
                        <div class="recommended-size">${data.bestKitSize.toFixed(3)}" / ${data.bestKitSizeMm.toFixed(2)} mm</div>
                        <div class="recommended-label">approximately ${pixelsWithBest.toFixed(1)} pixels per speckle</div>
                        <div class="ideal-size-note">
                            Ideal size for your setup: <strong>${displayIdeal.toFixed(4)} ${unitLabel}</strong> (4 pixels per speckle)
                        </div>
                    </div>
                `;
            } else {
                recommendationCard = `
                    <div class="recommendation-card">
                        <h4>Recommended Speckle Kit Size</h4>
                        <div class="recommended-size">${data.bestKitSize.toFixed(3)}" / ${data.bestKitSizeMm.toFixed(2)} mm</div>
                        <div class="recommended-label">approximately ${pixelsWithBest.toFixed(1)} pixels per speckle</div>
                    </div>
                `;
            }

            resultsDiv.innerHTML = `
                <div class="results-header">
                    <h3>Calculation Results</h3>
                    <p class="pixel-info">
                        Camera: ${data.cameraWidth} x ${data.cameraHeight} px |
                        FOV: ${data.fovWidth.toFixed(2)} x ${data.fovHeight.toFixed(2)} ${unitLabel} |
                        Pixel Scale: ${(data.pixelScale * (data.useInches ? 1000 : 25.4)).toFixed(4)} ${data.useInches ? 'mil' : 'mm'}/px
                    </p>
                </div>

                ${outOfRangeAlert}

                ${recommendationCard}

                <div class="speckle-range">
                    <div class="range-card">
                        <div class="label">Minimum Size (3 px/speckle)</div>
                        <div class="value">${displayMin.toFixed(4)} ${unitLabel}</div>
                        <div class="pixels">Lower limit for good correlation</div>
                    </div>
                    <div class="range-card">
                        <div class="label">Maximum Size (5 px/speckle)</div>
                        <div class="value">${displayMax.toFixed(4)} ${unitLabel}</div>
                        <div class="pixels">Upper limit for optimal resolution</div>
                    </div>
                </div>

                <div class="kit-sizes">
                    <h4>Available Speckle Kit Sizes <span style="font-weight:normal;color:#7f8c8d;">(colors match roller/stamp bands)</span></h4>
                    <div class="size-options">
                        ${data.categorizedSizes.map(s => `
                            <div class="size-chip ${s.colorClass} ${s.isRecommended ? 'recommended' : ''} ${!s.isAcceptable ? 'out-of-range' : 'acceptable'}"
                                 title="${s.pixels.toFixed(1)} pixels per speckle${s.isRecommended ? ' - RECOMMENDED' : ''}${!s.isAcceptable ? ' - Outside optimal range' : ''}">
                                ${s.sizeInches.toFixed(3)}" <span style="opacity:0.9">(${s.sizeMm.toFixed(2)}mm)</span>
                                <br><small>${s.pixels.toFixed(1)} px</small>
                            </div>
                        `).join('')}
                    </div>
                    <div class="legend">
                        <div class="legend-title">Kit Color Reference:</div>
                        <div class="legend-item">
                            <div class="legend-dot black"></div>
                            <span>0.007"</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot yellow"></div>
                            <span>0.013"</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot green"></div>
                            <span>0.026"</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot red"></div>
                            <span>0.05"</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot white"></div>
                            <span>0.10"</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-dot blue"></div>
                            <span>0.20"</span>
                        </div>
                        <div class="legend-item" style="margin-left: 20px; padding-left: 20px; border-left: 1px solid #ccc;">
                            <div class="legend-dot recommended-indicator"></div>
                            <span>= Recommended</span>
                        </div>
                    </div>
                </div>

                ${warningHtml}

                <div class="camera-specs">
                    <strong>Tip:</strong> For optimal DIC results, speckles should be 3-5 pixels in diameter (5-10 is also acceptable).
                    Speckles smaller than 3 pixels can cause aliasing artifacts. If two sizes work for your FOV,
                    choose the smaller one for better spatial resolution.
                </div>
            `;

            resultsDiv.classList.add('show');
            resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    </script>
</body>
</html>
